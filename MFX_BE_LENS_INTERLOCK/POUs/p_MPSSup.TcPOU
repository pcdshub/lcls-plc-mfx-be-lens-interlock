<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="p_MPSSup" Id="{22fa257d-fc87-4b8c-8293-563a03fa02d7}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM p_MPSSup
VAR
    BEAT: FB_HEARTBEAT;
    fbStateLatch : RS;
    fbLimitLatch : RS;
    fbTableLimitFaultLatch : RS;
    fbMinEnergyFaultLatch : RS;
    fbRequiresTransfocatorFaultLatch : RS;
    XRT_LENS_SYSTEM : FB_LENS_SYSTEM;
    TFS_LENS_SYSTEM : FB_LENS_SYSTEM;
    LIMIT_FAULT : BOOL;
    stActiveLimit : REFERENCE TO RADII_LIMIT;

    fEnergyMin : LREAL;
    fRequiresTransfocatorEnergyLow : LREAL;
    fRequiresTransfocatorEnergyHigh : LREAL;

    iLensIdx: INT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Latch fault state
////////////////////

fbStateLatch(SET:=bSTATE_FAULT, RESET1:=i_xFAULT_CLEAR);
q_xPOSITION_LATCH := fbStateLatch.Q1;

fbLimitLatch(SET:=q_bLimitSummaryFault, RESET1:=i_xFAULT_CLEAR);
q_xLIMIT_LATCH := fbLimitLatch.Q1;

fbTableLimitFaultLatch(SET:=bTableLimitFault, RESET1:=i_xFAULT_CLEAR);
q_bTableLimitFaultLatch := fbTableLimitFaultLatch.Q1;

fbMinEnergyFaultLatch(SET:=bMinEnergyFault, RESET1:=i_xFAULT_CLEAR);
q_bMinEnergyFaultLatch := fbMinEnergyFaultLatch.Q1;

fbRequiresTransfocatorFaultLatch(SET:=bRequiresTransfocatorFault, RESET1:=i_xFAULT_CLEAR);
q_bRequiresTransfocatorFaultLatch := fbRequiresTransfocatorFaultLatch.Q1;

//IOC Heartbeat
///////////////////////////////////////////////
BEAT(BEAT:=i_xIOC_HEARTBEAT,DEADTIME:=TIME#1.0S);
bHEARTBEATALIVE := BEAT.ALIVE;

//XRT LENS SYSTEM
///////////////////////////
XRT_LENS_SYSTEM(LENSES:=XRT_LENSES, COUNT:=3);
XRT_RADIUS := XRT_LENS_SYSTEM.EFF_RADII; (* Propagated to EPICS *)

//TFS LENS SYSTEM
///////////////////////////
TFS_LENS_SYSTEM(LENSES:=TFS_LENSES, COUNT:=10);
TFS_RADIUS := TFS_LENS_SYSTEM.EFF_RADII; (* Propagated to EPICS *)

(* Reset our tracking variables *)
bTableLimitFault := FALSE;
bMinEnergyFault := FALSE;
bRequiresTransfocatorFault := FALSE;

(* Determine which XRT lens is inserted, and pick the correct range based on it. *)

IF NOT XRT_LENS_SYSTEM.UNKNOWN_FAULT THEN
    IF XRT_LENS_SYSTEM.LENSES[1].IN THEN
        stActiveLimit REF= LENS1_LIMIT;
        iLensIdx := 1;
    ELSIF XRT_LENS_SYSTEM.LENSES[2].IN THEN
        stActiveLimit REF= LENS2_LIMIT;
        iLensIdx := 2;
    ELSIF XRT_LENS_SYSTEM.LENSES[3].IN THEN
        stActiveLimit REF= LENS3_LIMIT;
        iLensIdx := 3;
    ELSE
        stActiveLimit REF= NO_LENS_LIMIT;
        iLensIdx := 0;
    END_IF

	q_stActiveLimit.TRIP_LOW := stActiveLimit.TRIP_LOW;
	q_stActiveLimit.TRIP_HIGH := stActiveLimit.TRIP_HIGH;
	
    fEnergyMin := fMinEnergies[iLensIdx];
    fRequiresTransfocatorEnergyLow := afbRequiresLensEnergyRange[iLensIdx].fLow;
    fRequiresTransfocatorEnergyHigh := afbRequiresLensEnergyRange[iLensIdx].fHigh;

    IF stActiveLimit.TRIP_HIGH > stActiveLimit.TRIP_LOW THEN
        // Lens inserted and trip region specified:
        bTableLimitFault := (
            stActiveLimit.TRIP_LOW <= TFS_RADIUS AND TFS_RADIUS <= stActiveLimit.TRIP_HIGH
        );
    END_IF

    (*
    Regardless of transfocator setting, the minimum energy must be
    greater than or equal to that shown in the table (Minimum energy [keV]).
    Trip if below.
    *)
    bMinEnergyFault := i_fPhotonEnergy < fEnergyMin;

    (*
    When a pre-focusing lens is inserted, there exists a range of photon
    energies in which at least one transfocator lens must be inserted.
    If the current photon energy is within this (inclusive) range and no
    lens is inserted, trip.
    *)
    IF fRequiresTransfocatorEnergyHigh > fRequiresTransfocatorEnergyLow THEN
        (* Check that we're in the given photon energy range *)
        IF fRequiresTransfocatorEnergyLow <= i_fPhotonEnergy AND i_fPhotonEnergy <= fRequiresTransfocatorEnergyHigh THEN
            (* And if so, trip when IN_COUNT == 0 *)
            bRequiresTransfocatorFault := (TFS_LENS_SYSTEM.IN_COUNT < 1);
        END_IF
    END_IF

END_IF

//Summarize faults
///////////////////////////

q_bLimitSummaryFault := (
    bTableLimitFault OR         // Inside the table-defined trip range
    bMinEnergyFault OR			// Below minimum required energy for XRT lens
    bRequiresTransfocatorFault	// Require transfocator lens in this range
);

//State Violations
bSTATE_FAULT := (
    XRT_LENS_SYSTEM.UNKNOWN_FAULT OR  // XRT lens state unknown
    TFS_LENS_SYSTEM.UNKNOWN_FAULT OR  // Transfocator lens state unknown
    XRT_LENS_SYSTEM.IN_COUNT > 1      // Unexpected lens count
);

//Final Summary
bFAULT := q_bLimitSummaryFault OR bSTATE_FAULT OR NOT bHEARTBEATALIVE;
bTRIP_MPS := NOT bFAULT;]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>